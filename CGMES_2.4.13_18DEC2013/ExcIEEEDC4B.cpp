/*
Generated from the CGMES files via cimgen: https://github.com/sogno-platform/cimgen
*/
#include "ExcIEEEDC4B.hpp"

#include <algorithm>
#include <sstream>

#include "PU.hpp"
#include "PU.hpp"
#include "PU.hpp"
#include "PU.hpp"
#include "PU.hpp"
#include "PU.hpp"
#include "PU.hpp"
#include "PU.hpp"
#include "Boolean.hpp"
#include "Simple_Float.hpp"
#include "Simple_Float.hpp"
#include "Seconds.hpp"
#include "Seconds.hpp"
#include "Seconds.hpp"
#include "Seconds.hpp"
#include "Boolean.hpp"
#include "PU.hpp"
#include "PU.hpp"
#include "PU.hpp"

using namespace CIMPP;

ExcIEEEDC4B::ExcIEEEDC4B() {};
ExcIEEEDC4B::~ExcIEEEDC4B() {};


bool assign_ExcIEEEDC4B_efd1(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->efd1;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_efd2(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->efd2;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_ka(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->ka;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_kd(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->kd;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_ke(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->ke;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_kf(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->kf;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_ki(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->ki;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_kp(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->kp;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_oelin(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->oelin;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_seefd1(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->seefd1;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_seefd2(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->seefd2;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_ta(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->ta;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_td(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->td;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_te(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->te;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_tf(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->tf;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_uelin(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->uelin;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_vemin(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->vemin;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_vrmax(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->vrmax;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}

bool assign_ExcIEEEDC4B_vrmin(std::stringstream &buffer, BaseClass* BaseClass_ptr1)
{
	if (ExcIEEEDC4B* element = dynamic_cast<ExcIEEEDC4B*>(BaseClass_ptr1))
	{
		buffer >> element->vrmin;
		if (buffer.fail())
			return false;
		else
			return true;
	}
	return false;
}





















const char ExcIEEEDC4B::debugName[] = "ExcIEEEDC4B";
const char* ExcIEEEDC4B::debugString() const
{
	return ExcIEEEDC4B::debugName;
}

void ExcIEEEDC4B::addConstructToMap(std::unordered_map<std::string, BaseClass* (*)()>& factory_map)
{
	factory_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B"), &ExcIEEEDC4B_factory));
}

void ExcIEEEDC4B::addPrimitiveAssignFnsToMap(std::unordered_map<std::string, assign_function>& assign_map)
{
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.efd1"), &assign_ExcIEEEDC4B_efd1));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.efd2"), &assign_ExcIEEEDC4B_efd2));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.ka"), &assign_ExcIEEEDC4B_ka));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.kd"), &assign_ExcIEEEDC4B_kd));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.ke"), &assign_ExcIEEEDC4B_ke));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.kf"), &assign_ExcIEEEDC4B_kf));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.ki"), &assign_ExcIEEEDC4B_ki));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.kp"), &assign_ExcIEEEDC4B_kp));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.oelin"), &assign_ExcIEEEDC4B_oelin));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.seefd1"), &assign_ExcIEEEDC4B_seefd1));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.seefd2"), &assign_ExcIEEEDC4B_seefd2));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.ta"), &assign_ExcIEEEDC4B_ta));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.td"), &assign_ExcIEEEDC4B_td));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.te"), &assign_ExcIEEEDC4B_te));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.tf"), &assign_ExcIEEEDC4B_tf));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.uelin"), &assign_ExcIEEEDC4B_uelin));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.vemin"), &assign_ExcIEEEDC4B_vemin));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.vrmax"), &assign_ExcIEEEDC4B_vrmax));
	assign_map.insert(std::make_pair(std::string("cim:ExcIEEEDC4B.vrmin"), &assign_ExcIEEEDC4B_vrmin));
}

void ExcIEEEDC4B::addClassAssignFnsToMap(std::unordered_map<std::string, class_assign_function>& assign_map)
{
}

const BaseClassDefiner ExcIEEEDC4B::declare()
{
	return BaseClassDefiner(ExcIEEEDC4B::addConstructToMap, ExcIEEEDC4B::addPrimitiveAssignFnsToMap, ExcIEEEDC4B::addClassAssignFnsToMap, ExcIEEEDC4B::debugName);
}

namespace CIMPP
{
	BaseClass* ExcIEEEDC4B_factory()
	{
		return new ExcIEEEDC4B;
	}
}
